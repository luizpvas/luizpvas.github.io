<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Learning bidirectional type checking</title>
    <link rel="stylesheet" href="index.css" />
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7TMTHS88G9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7TMTHS88G9');
    </script>
  </head>
  <body class="bg-slate-100 dark:bg-slate-800 dark:text-white">
    <main class="max-w-screen-md mx-4 lg:mx-auto pt-4">
      <a href="index.html" class="inline-flex border dark:border-slate-900 items-center bg-slate-200 dark:bg-slate-700 hover:border-blue-500 px-3 py-1 rounded-full">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
          <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
        </svg>

        <span class="ml-1">All posts</span>
      </a>

      <div class="border-b-2 dark:border-slate-900 mb-4">
        <h1 class="my-6 text-5xl tracking-tight">Learning bidirectional type checking</h1>
        <div class="text-slate-500 dark:text-slate-300 my-2">Published on 2025-08-13</div>
      </div>

      <div class="prose dark:prose-invert lg:prose-xl mb-12">
        <blockquote>
<p>Note: I promised myself that I would write an article once I understood how
bidirectional type checking works. <a href="https://arxiv.org/abs/1306.6032">The paper</a>
opens with a claim that the algorithm is extraordinarily simple, which immediately
hit the ego because I had no idea what I was reading. I just couldn&#39;t wrap my head
around what any of the typing rules and typing judgments meant. I powered through
it and eventually understood it. So here I am, 3 months later, writing this article
as promised.</p>
</blockquote>

<p>This article is intended for people interested in building their own programming
language with little programming language theory and type theory background who
are struggling with papers telling you their algorithm is extraordinarily simple
and then giving you this:</p>

<p><img src="/images/11_01.png" alt="image"></p>

<p>After fighting with <a href="https://arxiv.org/abs/1306.6032">Complete and Easy Bidirectional Typechecking for
Higher-Rank Polymorphism</a> for a while, I
think I agree that it is actually simple, especially compared with
algorithms that require constraint solving and unification. It is simple, but
definitely not easy. We have some work ahead of us.</p>

<blockquote>
<p>Note: I do think you&#39;ll eventually need to learn proper programming language
theory and type theory to complete your language, but you can definitely
build a proof of concept without deep background in those subjects.</p>
</blockquote>

<h3>Type checking</h3>

<p>Type checking is the process that verifies if an expression is well typed. Type
checking might also produce annotations that you can carry forwards for later compiler passes.</p>

<p>Expressions are usually obtained from parsing, which is the process that converts
text, the source code, into a data structure that is better suited for inspection
and manipulation. The data structure is usually a tree, where each node represents
an expression and its children represent its subexpressions.</p>

<p>For the rest of this article, we&#39;ll talk about a made up programming language
with primitives (integers, bools, strings, etc.) and functions.
At the end of this article we&#39;ll look at array literals and sum types.</p>

<h3>The <code>synthesize</code> function</h3>

<p>There are two distinct functions at the core of the bidirectional type checking algorithm
that call each other, recursively, in order to resolve the type of an expression.
Those functions are <code>synthesize</code>, which infers the type of an expression, and
<code>check</code>, which checks if the expression has the expected type. For learning
purposes, it is sufficient to think of their signatures as:</p>

<pre><code class="haskell">synthesize :: Expression -&gt; Type
check :: Expression -&gt; Type -&gt; Bool
</code></pre>

<p>At this moment, we have no expressions nor types to work with, so let&#39;s
draw a starting line.</p>

<pre><code class="haskell">data Expression
  = LiteralInt Int
  | LiteralString String

data Type
  = TInt
  | TString
</code></pre>

<p>The implementation of the <code>synthesize</code> function is pretty straight forward for
this set of expressions and types.</p>

<pre><code class="haskell">synthesize :: Expression -&gt; Type
synthesize expression =
  case expression of
    LiteralInt _ -&gt; TInt
    LiteralString _ -&gt; TString
</code></pre>

<p>In fact, the <code>synthesize</code> implementation is the same for all literal primitive
types. If we added support for booleans, dates and datetimes, they would
be just as simple.</p>

<p>The typing rule for literals is described as follows:</p>

<p><img src="/images/11_02.png" alt=""></p>

<p>&quot;1I=&gt;&quot; is the name of the typing rule. &quot;1&quot; means unit, &quot;I&quot; means introduction,
and &quot;=&gt;&quot; means synthesis. You can read the name as &quot;the typing rule for synthesizing unit&quot;,
or &quot;the typing rule for synthesizing literals&quot;.</p>

<p>Notice there is a line with nothing above it. The fact that there is nothing above
the line means that the typing rule has no premises, that is, it is always true
in all contexts. For example, the literal 2 always synthesizes the type <code>Int</code>
no matter which program you are type checking. Contrast this to synthesizing,
let&#39;s say, a variable named <code>email</code>. Which type should it synthesize? Depends,
right? Depends on the program you are type checking. The fact that it depends on
a context means that the typing rule will have a premise, that is, a typing
judgment above the line.</p>

<p>You can read the conclusion, what is underneath the line, as &quot;under context gamma,
the unit literal synthesizes the type <code>Unit</code>, and produces the same context gamma&quot;.</p>

<h3>Contexts</h3>

<p>For the unit/literal typing rule, the context does not matter. Whatever we receive
as input we return the same value as output. But this will not be the case for
all typing rules. In fact, the context does not matter only for the unit/literal
typing rule.</p>

<p>The context is a container that holds symbols and their types currently in scope
(and some other stuff we&#39;ll talk about later). The paper calls it an algorithmic
context. The data structure behind it is a list, where the order of the elements
in the list is the order they appeared in the code. For example if we have
the code</p>

<pre><code>let id = 10
let email = &quot;person@example.org&quot;
</code></pre>

<p>We would push <code>id</code> and <code>email</code>, in that order, into the context.</p>

      </div>
    </main>
  </body>
</html>
