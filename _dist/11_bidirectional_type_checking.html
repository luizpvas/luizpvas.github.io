<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bidirectional type checking</title>
    <link rel="stylesheet" href="index.css" />

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7TMTHS88G9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7TMTHS88G9');
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/haskell.min.js"></script>
  </head>
  <body class="bg-slate-100 dark:bg-slate-800 dark:text-white">
    <main class="max-w-screen-md mx-4 lg:mx-auto pt-4">
      <a href="index.html" class="inline-flex border dark:border-slate-900 items-center bg-slate-200 dark:bg-slate-700 hover:border-blue-500 px-3 py-1 rounded-full">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
          <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
        </svg>

        <span class="ml-1">All posts</span>
      </a>

      <div class="border-b-2 dark:border-slate-900 mb-4">
        <h1 class="my-6 text-5xl tracking-tight">Bidirectional type checking</h1>
        <div class="text-slate-500 dark:text-slate-300 my-2">Published on 2025-08-13</div>
      </div>

      <div class="prose dark:prose-invert lg:prose-xl mb-12">
        <p>This article is intended for people struggling with papers telling you their
algorithm is extraordinarily simple and then giving you this:</p>

<p><img src="/images/11_01.png" alt="image"></p>

<p>After fighting with <a href="https://arxiv.org/abs/1306.6032">Complete and Easy Bidirectional Typechecking for
Higher-Rank Polymorphism</a> for a while, I
I agree that it is actually simple, especially compared to
algorithms that require constraint solving and unification. It is simple, but
definitely not easy. We have some work ahead of us.</p>

<h3>Type checking</h3>

<p>Type checking is the process that validates expressions against type rules.</p>

<p>Expressions are usually obtained from parsing, which is the process that converts
text, the source code, into a data structure that is better suited for inspection
and manipulation. The data structure is usually a tree, commonly referred to as
AST, where each node represents an expression pointing to its subexpressions.</p>

<p>For the rest of this article, we&#39;ll talk about a made up programming language
with literals for integers and strings, variables and functions.
We&#39;ll also look at array literals and sum types at the end.</p>

<h3>The <code>synthesize</code> function</h3>

<p>There are two distinct functions at the core of bidirectional type checking
that call each other, recursively, in order to resolve the type of an expression.
Those functions are <code>synthesize</code>, which infers the type of an expression, and
<code>check</code>, which checks if the expression has the expected type. For learning
purposes, it is sufficient to think of their signatures as:</p>

<pre><code class="ruby">def synthesize(expr)  # returns a type
def check(expr, type) # returns true or false
</code></pre>

<p>At this moment, we have no expressions nor types to work with, so let&#39;s
draw a starting line.</p>

<pre><code class="ruby">module Expression
  LiteralInt = Data.define(:value)
  LiteralString = Data.define(:value)
end

module Type
  Int = Data.define
  String = Data.define
end
</code></pre>

<p>The implementation for <code>synthesize</code> is the following for this set of expressions
and types:</p>

<pre><code class="ruby">def synthesize(expr)
  case expr
  in Expression::LiteralInt
    Type::Int.new
  in Expression::LiteralString
    Type::String.new
  else
    raise &quot;unknown expression&quot;
  end
end
</code></pre>

<p>All literal primitives follow this pattern. If we added
support for dates, datetimes, regexs, etc., they would all be new entries
to this pattern match.</p>

<p>The typing rule for unit (and literals) is described as follows:</p>

<p><img src="/images/11_02.png" alt="Typing rule for unit"></p>

<p>The &quot;1I=&gt;&quot; on the right hand side is the name of the typing rule. &quot;1&quot; means unit, &quot;I&quot; means introduction,
and &quot;=&gt;&quot; means synthesis. You can read the name as &quot;the typing rule for synthesizing unit&quot;,
or &quot;the typing rule for synthesizing literals&quot;.</p>

<p>Notice there is a line in the middle with nothing above it. This means that the typing rule has
no premises, so it is always true in all contexts. For example, the literal
<code>2</code> always synthesizes the type <code>Int</code> in all contexts.
Contrast this to synthesizing, let&#39;s say, a variable named <code>email</code>. Which type
should it synthesize? Probably <code>String</code>, but depends, right?
The fact that it depends means that the typing rule for variables
must have a premise.</p>

<p>You can read the conclusion, what is below the line, as &quot;under context gamma,
the unit value synthesizes the type <code>Unit</code>, and produces the same context gamma&quot;.</p>

<h3>Contexts</h3>

<p>For the unit type rule, the context does not matter. Whatever we receive
as input we return the same value as output. But this is not the case for
other typing rules.</p>

<p>The context is a container that holds symbols, like variable names, function names, module names, etc.,
and their types (and some other stuff we&#39;re about to see).
The data structure for context is a list, where the order of the elements
in the list is the order they appear in the code. For example, the
following pseudo-js-code</p>

<pre><code class="js">let id = 10;
let email = &quot;person@example.org&quot;;
</code></pre>

<p>would push <code>id : Int</code> and <code>email : String</code>, in that order, into the context.</p>

<h3>Variables</h3>

<p>Before we can synthesize the type of a variable we need to add a new constructor
to our expression type.</p>

<pre><code class="diff">module Expression
  LiteralInt = Data.define(:value)
  LiteralString = Data.define(:value)
+ Variable = Data.define(:name)
end
</code></pre>

<p>Then, update the <code>synthesize</code> function with a new pattern.</p>

<pre><code class="diff">def synthesize(expr)
  case expr
  in Expression::LiteralInt
    Type::Int.new
  in Expression::LiteralString
    Type::String.new
+ in Expression::Variable(name)
+   # what do we do here?
  else
    raise &quot;unknown expression&quot;
  end
end
</code></pre>

<p>To implement the variable case we need to lookup the name in a context. So let&#39;s
tweak our typing functions to take a context as an argument. The signature I
showed earlier was a simplified version. The real signatures of <code>synthesize</code> and
<code>check</code> are:</p>

<pre><code class="ruby">def synthesize(expr, context)  # returns a (type, context)
def check(expr, type, context) # returns (boolean, context)
</code></pre>

<p>The implementation of synthesize, considering the new variable case properly
handling context input and output is the following:</p>

<pre><code class="ruby">def synthesize(expr, context)
  case expr
  in Expression::LiteralInt
    [Type::Int.new, context]

  in Expression::LiteralString
    [Type::String.new, context]

  in Expression::Variable(varname)
    vartype = context.lookup(varname)
    return [vartype, context] if vartype
    raise &quot;unknown variable&quot;

  else
    raise &quot;unknown expression&quot;
  end
end
</code></pre>

<p>The literal cases now return the given context as-is. The
variable case defers to <code>Context#lookup</code> to retrieve the type of the variable
from the context. It then returns the same context without modifications.</p>

<p>We still haven&#39;t seen what <code>Context</code> is, and the implementation of <code>Context#lookup</code>, but
before we get there, the typing rule for synthesizing variables is the following:</p>

<p><img src="/images/11_03.png" alt="Typing rule for variables"></p>

<p>Here&#39;s how to read it: &quot;The typing rule for synthesizing variables
states that, under context gamma, <code>x</code> synthesizes type <code>A</code> and produces
the same context gamma if gamma contains the annotation <code>x : A</code>&quot;.</p>

<h3>Back to contexts</h3>

<p>Contexts contain declarations of quantifications (forall), term
variable typings and existentials, both solved and unsolved. The underlying
data structure is a list, where the order of the elements represent the order
of the facts we have gathered from the program we are type checking.</p>

<p>Let&#39;s define the <code>Context</code> type as a list of <code>Element</code> and implement the
<code>lookup</code> function we need.</p>

<pre><code class="ruby">class Context
  module Element
    TypedVariable = Data.define(:name, :type)
  end

  def initialize
    @elements = []
  end

  def lookup(name)
    typedvar = @elements.find do |element|
      case element
      in Element::TypedVariable(varname, _) then varname == name
      else false
      end
    end

    typedvar&amp;.then { it.type }
  end
end
</code></pre>

<p>Apart from the fact we cannot yet add definitions to the context, with the code
above we can successfully synthesize variables.</p>

<h3>Annotations</h3>

<p>The next typing rule for our language is annotation. It does not
matter if the language defines annotation as a separate construct (like Haskell)
from functions and values or if annotations are written next to the expressions
(like Typescript).</p>

<p>The rule synthesizing annotations is as follows:</p>

<p><img src="/images/11_04.png" alt="annotation_type_rule"></p>

<p>This is a bit more complicated than we have seen so far.
The conclusion of this typing rule states that &quot;under context gamma, <code>e has type A</code>
synthesizes type <code>A</code> and produces context delta&quot;.</p>

<p>Synthesizing type <code>A</code> for the annotation <code>e : A</code> seems kinda redundant,
but the premise of the rule provides interesting guarantees. First, <code>A</code> must
be well formed. This is denoted by the expression <code>Γ ⊢ A</code>. This ensures that
the annotation references a valid type in the program.</p>

<p>The second part of the premise, <code>Γ ⊢ e &lt;= A ⊣ Δ</code>, adds an extra correctness
guarantee to the process. The compiler cannot simply trust the annotation
and assume <code>e</code> actually have type <code>A</code>. Doing so would make the type
system unsound. So instead of trusting, we need to check.</p>

<blockquote>
<p>Just to be clear we&#39;re on the same page about the notation, <code>e =&gt; A</code> is read
as &quot;e synthesizes type A&quot; and <code>e &lt;= A</code> is read as &quot;e checks against type A&quot;.</p>
</blockquote>

<p>This rule is our first encounter with the recursion between synthesizing
and checking. In order to synthesizse annotation expression we need to
check it, and during checking we might need to synthesize.</p>

<h3>Is the type well formed?</h3>

<p>The first premise of synthesizing the annotation <code>e : A</code> ensures that the
type <code>A</code> is well formed. The following set of rules describe the well-formedness
of types:</p>

<p><img src="/images/11_05.png" alt="annotation_type_rule"></p>

<p>You can read this rules as:</p>

<ul>
<li><strong>UvarWF</strong>: A type variable is well formed if it exists in the context. Do not
confuse type variables with expression variable.</li>
<li><strong>UnitWF</strong>: The unit type is always well formed. The same is true for all literal types.</li>
<li><strong>ArrowWF</strong>: The function type <code>A -&gt; B</code> is well formed if <code>A</code> and <code>B</code> are well formed.</li>
<li><strong>ForallWF</strong>: The quantification <code>forall x.A</code> is well formed if <code>A</code> is well formed under
context gamma with <code>x</code> added to gamma.</li>
<li><strong>EvarWF</strong>: The existential type <code>â</code> is well formed if it exists in the context.</li>
<li><strong>SolvedEvarWF</strong>: The solved existential type <code>â</code> is well formed if it exists in the context.</li>
</ul>

<p>We haven&#39;t talked about type variables, quantification and existentials, but it
is useful to see the whole definition. The implementation of this
function would look the following for the types we already have:</p>

<pre><code class="ruby">def type_well_formed?(type, context)
  case type
  in Type::Int then true # UnitWF rule
  in Type::String then true # UnitWF rule
  else raise &quot;unknown type: #{type}&quot;
  end
end
</code></pre>

<h3>Checking</h3>

<p>The second premise of synthesizing the annotation <code>e has type A</code> ensures that
the program is not lying to the compiler. It checks that the expression <code>e</code>
type checks against <code>A</code>.</p>

<p>In order to implement <code>check</code> we need at least one typing rule, so let&#39;s stash
the annotation synthesize rule and look at the simplest rule for checking
literals:</p>

<p><img src="/images/11_06.png" alt="type_rule_check_literal"></p>

<p>This is very, very similar to the rule for synthesizing literals. The only
difference is that arrows are flipped. The implementation of check is as follows:</p>

<pre><code class="ruby">def check(expr, type, context)
  case [expr, type]

  in [Expression::LiteralInt, Type::Int]
    context

  in [Expression::LiteralString, Type::String]
    context

  else
    raise &quot;type mismatch&quot;
  end
end
</code></pre>

<p>Instead of returning bools to indicate if it typed checked or not, we&#39;re going to
raise an error when a type mismatch occurs, and we&#39;re going to successfully return
when valid.</p>

<h3>Back to synthesizing annotations</h3>

<p>We now have enough structure in place to synthesize annotations.</p>

<pre><code class="diff">module Expression
  LiteralInt = Data.define(:value)
  LiteralString = Data.define(:value)
  Variable = Data.define(:name)
+ Annotation = Data.define(:expression, :type)
end

def synthesize(expr, context)
  case expr
  in Expression::LiteralInt
    [Type::Int.new, context]

  in Expression::LiteralString
    [Type::String.new, context]

  in Expression::Variable(varname)
    vartype = context.lookup(varname)
    return [vartype, context] if vartype
    raise &quot;unknown variable&quot;

+ in Expression::Annotation(e, type)
+   if type_well_formed?(type, context)
+     delta = check(e, type, context)
+     [type, delta]
+   else
+     raise &quot;invalid type&quot;
+   end

  else
    raise &quot;unknown expression&quot;
  end
end
</code></pre>

<h3>Checkpoint 01</h3>

<p>So far our implementation allows the following expressions to be typed:</p>

<pre><code class="ruby">synthesize(
  Expression::LiteralInt.new(42),
  Context.new
) # =&gt; #&lt;data Type::Int&gt;

synthesize(
  Expression::Annotation.new(
    Expression::LiteralString.new(&quot;hello&quot;),
    Type::String.new
  ),
  Context.new
) # =&gt; #&lt;data Type::String&gt;

synthesize(
  Expression::Annotation.new(
    Expression::LiteralString.new(&quot;hello&quot;),
    Type::Int.new
  ),
  Context.new
) # =&gt; type mismatch (RuntimeError)
</code></pre>

<h3>Functions</h3>

<p>The typing rule for synthesizing functions is the following:</p>

<p><img src="/images/11_07.png" alt="type_rule_synthesize_function"></p>

<p>This rule introduces a new concept we haven&#39;t talked about yet: existential
types. The symbol ^ is used exclusively to denotate existentials. The conclusion
of this typing rule is read as: &quot;Under context gamma, lambda from <code>x</code> to <code>e</code>
synthesizes the type lambda from <code>existential alpha</code> to <code>existential beta</code> and produces a
new context delta&quot;.</p>

<p>Alpha and beta are known as fresh existentials. Existential types can be thought of as
unknown types. They&#39;re unknown up to this point of the type checking process, but we
can gather more information to figure out what they are. Important: they&#39;re not like
<code>any</code> or <code>void</code>, but placeholder for a type that is yet to be determined.</p>

<p>The word fresh is commonly used in type theory and type checking to refer to newly
created variables that are guaranteed to be distinct from other variables currently in scope.
To implement this rule, we&#39;ll need a function that generates fresh names (unique names).
For simplicity, we&#39;ll use a global counter, but feel free to wrap the type checking
in a class if you&#39;re using an OOP language or a monad that controls state and exceptions
if you&#39;re using FP language.</p>

<pre><code class="ruby">$fresh_name_counter = 0
def fresh_name
  $fresh_name_counter += 1
  &quot;x#{$fresh_name_counter}&quot;
end

fresh_name # =&gt; &quot;x1&quot;
fresh_name # =&gt; &quot;x2&quot;
fresh_name # =&gt; &quot;x3&quot;
</code></pre>

<p>We can break the the premise of this typing rule into three parts in order to
understand it better.</p>

<p><img src="/images/11_08.png" alt="type_rule_synthesize_function_breakdown"></p>

<p>The middle part, highlighted in pink, is a recursive call to <code>check</code>. It checks
that <code>e</code>, the body of the function, checks against existential beta.</p>

<p>The first part, highlighted in red, modifies the context gamma by pushing 3
new elements to it: existential alpha, existential beta, and an annotation
(typed variable) that <code>x has type existential alpha</code>. This modified context
is the context we&#39;ll pass to <code>check</code> when checking the body of the function.</p>

<p>The last part, highlighted in green, can be seen as a pattern match. We match on
the output of <code>check</code> on <code>x has type existential alpha</code> binding the elements to
left to delta and the elements to the right to theta. Remember that the context
is a list of elements.</p>

      </div>
    </main>

    <script>hljs.highlightAll();</script>
  </body>
</html>
