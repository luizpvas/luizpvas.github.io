<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bidirectional type checking step by step</title>
    <link rel="stylesheet" href="index.css" />

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7TMTHS88G9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7TMTHS88G9');
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/haskell.min.js"></script>
  </head>
  <body class="bg-slate-100 dark:bg-slate-800 dark:text-white">
    <main class="max-w-[960px] mx-auto pt-4">
      <a href="index.html" class="inline-flex border border-gray-300 dark:border-slate-900 items-center bg-slate-50 dark:bg-slate-700 hover:bg-white hover:border-black px-3 py-1 rounded-full">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
          <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
        </svg>

        <span class="ml-1">All posts</span>
      </a>

      <div class="dark:border-slate-900 mb-4">
        <h1 class="my-6 text-5xl tracking-tight">Bidirectional type checking step by step</h1>
        <div class="text-slate-500 dark:text-slate-300 my-2">Published on 2025-08-13</div>
      </div>

      <div class="prose dark:prose-invert lg:prose-xl mb-12 bg-white shadow-lg rounded-xl mx-auto max-w-[960px] p-8">
        <p>This article is intended for people with little experience in type theory and programming
language theory struggling with papers telling them their algorithm is extraordinarily simple before showing this:</p>

<p><img src="/images/11_01.png" alt="image"></p>

<p>After fighting with <a href="https://arxiv.org/abs/1306.6032">Complete and Easy Bidirectional Typechecking for
Higher-Rank Polymorphism</a> for a while, I
I agree that it is actually simple, especially compared to
algorithms that require constraint solving and unification. It is simple, but
definitely not easy. We have some work ahead of us.</p>

<p>If you want to skip ahead and look at the implementation, the code is available
on <a href="https://gist.github.com/luizpvas/4f13ac409095c08bb8c0616af53104e4">this gist</a>.</p>

<h3>Type checking</h3>

<p>Type checking is the process that validates expressions against type rules. This is
the core of the algorithm we&#39;re about to implement.</p>

<p>For the rest of this article, we&#39;ll talk about a made up programming language
with literals for integers and strings and functions.</p>

<h3>The <code>synthesize</code> function</h3>

<p>There are two distinct functions at the core of bidirectional type checking
that call each other, recursively, in order to resolve the type of an expression.
Those functions are <code>synthesize</code>, which infers the type of an expression, and
<code>check</code>, which checks if the expression has the expected type. For now
it is sufficient to think of their signatures as:</p>

<pre><code class="ruby">def synthesize(expr)  # returns a type
def check(expr, type) # returns true or false
</code></pre>

<p>At this moment, we have no expressions nor types to work with, so let&#39;s
draw a starting line.</p>

<pre><code class="ruby">module Expression
  LiteralInt = Data.define(:value)
  LiteralString = Data.define(:value)
end

module Type
  Int = Data.define
  String = Data.define
end
</code></pre>

<p>The implementation for <code>synthesize</code> is the following for this set of expressions
and types:</p>

<pre><code class="ruby">def synthesize(expr)
  case expr
  in Expression::LiteralInt
    Type::Int.new
  in Expression::LiteralString
    Type::String.new
  else
    raise &quot;unknown expression&quot;
  end
end
</code></pre>

<p>All literal primitives follow this pattern. If we added
support for dates, datetimes, regexs, etc., they would all be new entries
to this pattern match.</p>

<p>The typing rule for unit (and literals) is described as follows:</p>

<p><img src="/images/11_02.png" alt="Typing rule for unit"></p>

<p>The &quot;1I=&gt;&quot; on the right hand side is the name of the typing rule. &quot;1&quot; means unit, &quot;I&quot; means introduction,
and &quot;=&gt;&quot; means synthesis. We can read the name as &quot;the typing rule for synthesizing unit&quot;,
or &quot;the typing rule for synthesizing literals&quot;.</p>

<p>Notice there is a line in the middle with nothing above it. This means that the typing rule has
no premises, so it is always true in all contexts. For example, the literal
<code>2</code> always synthesizes the type <code>Int</code> in all contexts.
Contrast this to synthesizing, let&#39;s say, a variable named <code>email</code>. Which type
should it synthesize? Probably <code>String</code>, but depends, right?
The fact that it depends means that the typing rule for variables
must have a premise.</p>

<p>We can read the conclusion, what is below the line, as &quot;under context gamma,
the unit value synthesizes the type <code>Unit</code>, and produces the same context gamma&quot;.</p>

<h3>Contexts</h3>

<p>For the unit type rule, the context does not matter. Whatever we receive
as input we return the same value as output. But this is not the case for
other typing rules.</p>

<p>The context is a container that holds symbols, like variable names, function names, module names, etc.,
and their types (and some other stuff we&#39;re about to see).
The data structure for context is a list, where the order of the elements
in the list is the order they appear in the code. For example, the
following code...</p>

<pre><code class="js">let id = 10;
let email = &quot;person@example.org&quot;;
</code></pre>

<p>...would push <code>id : Int</code> and <code>email : String</code>, in that order, into the context.</p>

<h3>Variables</h3>

<p>Before we can synthesize the type of a variable we need to add a new constructor
to our expression type.</p>

<pre><code class="diff">module Expression
  LiteralInt = Data.define(:value)
  LiteralString = Data.define(:value)
+ Variable = Data.define(:name)
end
</code></pre>

<p>Then, update the <code>synthesize</code> function with a new pattern.</p>

<pre><code class="diff">def synthesize(expr)
  case expr
  in Expression::LiteralInt
    Type::Int.new
  in Expression::LiteralString
    Type::String.new
+ in Expression::Variable(name)
+   # what do we do here?
  else
    raise &quot;unknown expression&quot;
  end
end
</code></pre>

<p>To implement the variable case we need to lookup the name in a context. So let&#39;s
tweak our typing functions to take a context as an argument. The signature I
showed earlier was a simplified version. The real signatures of <code>synthesize</code> and
<code>check</code> are:</p>

<pre><code class="ruby">def synthesize(expr, context)  # returns a (type, context)
def check(expr, type, context) # returns context or raises an error if the type is not compatible
</code></pre>

<p>The implementation of synthesize, considering the new variable case properly
handling context input and output is the following:</p>

<pre><code class="ruby">def synthesize(expr, context)
  case expr
  in Expression::LiteralInt
    [Type::Int.new, context]

  in Expression::LiteralString
    [Type::String.new, context]

  in Expression::Variable(varname)
    vartype = context.lookup(varname)
    raise &quot;unknown variable&quot; if !vartype
    [vartype, context]

  else
    raise &quot;unknown expression&quot;
  end
end
</code></pre>

<p>The literal cases now return the given context as-is. The
variable case defers to <code>Context#lookup</code> to retrieve the type of the variable
from the context. It then returns the same context without modifications.</p>

<p>We still haven&#39;t seen what <code>Context</code> is, and the implementation of <code>Context#lookup</code>, but
before we get there, the typing rule for synthesizing variables is the following:</p>

<p><img src="/images/11_03.png" alt="Typing rule for variables"></p>

<p>Here&#39;s how to read it: &quot;The typing rule for synthesizing variables
states that, under context gamma, <code>x</code> synthesizes type <code>A</code> and produces
the same context gamma if gamma contains the annotation <code>x : A</code>&quot;.</p>

<h3>Back to contexts</h3>

<p>Contexts contain declarations of quantifications (forall), term
variable typings and existentials, both solved and unsolved. The underlying
data structure is a list, where the order of the elements represent the order
of the facts we have gathered from the program we are type checking.</p>

<p>Let&#39;s define the <code>Context</code> type as a list of <code>Element</code> and implement the
<code>lookup</code> function we need.</p>

<pre><code class="ruby">class Context
  module Element
    TypedVariable = Data.define(:name, :type)
  end

  def initialize
    @elements = []
  end

  def lookup(name)
    typed_var =
      @elements.find do |element|
        case element
        in Element::TypedVariable(varname, _) then varname == name
        else false
        end
      end

    typed_var&amp;.then { it.type }
  end
end
</code></pre>

<p>W the code above we can successfully synthesize variables.</p>

<h3>Annotations</h3>

<p>The next typing rule for our language is annotation. It does not
matter if the language defines annotation as a separate construct (like Haskell)
or if annotations are written next to the expressions (like Typescript).</p>

<p>The rule synthesizing annotations is as follows:</p>

<p><img src="/images/11_04.png" alt="annotation_type_rule"></p>

<p>This is a bit more complicated than we have seen so far.
The conclusion of this typing rule states that &quot;under context gamma, <code>e has type A</code>
synthesizes type <code>A</code> and produces context delta&quot;.</p>

<p>Synthesizing type <code>A</code> for the annotation <code>e : A</code> seems kinda redundant,
but the premise of the rule provides interesting guarantees. First, <code>A</code> must
be well formed. This is denoted by the expression <code>Γ ⊢ A</code>. This ensures that
the annotation references a valid type in the program.</p>

<p>The second part of the premise, <code>Γ ⊢ e &lt;= A ⊣ Δ</code>, adds an extra correctness
guarantee to the process. The compiler cannot simply trust the annotation
and assume <code>e</code> actually have type <code>A</code>. Doing so would make the type
system unsound. So instead of trusting, we need to check.</p>

<blockquote>
<p>Just to be clear we&#39;re on the same page about the notation, <code>e =&gt; A</code> is read
as &quot;e synthesizes type A&quot; and <code>e &lt;= A</code> is read as &quot;e checks against type A&quot;.</p>
</blockquote>

<p>This rule is our first encounter with the recursion between synthesizing
and checking. In order to synthesizse annotation expression we need to
check it, and during checking we might need to synthesize.</p>

<h3>Is the type well formed?</h3>

<p>The first premise of synthesizing the annotation <code>e : A</code> ensures that the
type <code>A</code> is well formed. The following set of rules describe the well-formedness
of types:</p>

<p><img src="/images/11_05.png" alt="annotation_type_rule"></p>

<p>We can read these rules as:</p>

<ul>
<li><strong>UvarWF</strong>: A type variable is well formed if it exists in the context. Do not
confuse type variables with expression variable.</li>
<li><strong>UnitWF</strong>: The unit type is always well formed. The same is true for all literal types.</li>
<li><strong>ArrowWF</strong>: The function type <code>A -&gt; B</code> is well formed if <code>A</code> and <code>B</code> are well formed.</li>
<li><strong>ForallWF</strong>: The quantification <code>forall x.A</code> is well formed if <code>A</code> is well formed under
context gamma with <code>x</code> added to gamma.</li>
<li><strong>EvarWF</strong>: The existential type <code>â</code> is well formed if it exists in the context.</li>
<li><strong>SolvedEvarWF</strong>: The solved existential type <code>â</code> is well formed if it exists in the context.</li>
</ul>

<p>We haven&#39;t talked about type variables, quantification and existentials, but it
is useful to see the whole definition. The implementation of this
function would look the following for the types we already have:</p>

<pre><code class="ruby">def type_well_formed?(type, context)
  case type
  in Type::Int then true # UnitWF rule
  in Type::String then true # UnitWF rule
  else raise &quot;unknown type: #{type}&quot;
  end
end
</code></pre>

<h3>Checking</h3>

<p>The second premise of synthesizing the annotation <code>e has type A</code> ensures that
the program is not lying to the compiler. It checks that the expression <code>e</code>
type checks against <code>A</code>.</p>

<p>In order to implement <code>check</code> we need at least one typing rule, so let&#39;s stash
the annotation synthesize rule in our head and look at the simplest rule for checking
literals:</p>

<p><img src="/images/11_06.png" alt="type_rule_check_literal"></p>

<p>This is very, very similar to the rule for synthesizing literals. The only
difference is that arrows are flipped. The implementation of check is as follows:</p>

<pre><code class="ruby">def check(expr, type, context)
  case [expr, type]

  in [Expression::LiteralInt, Type::Int]
    context

  in [Expression::LiteralString, Type::String]
    context

  else
    raise &quot;type mismatch: #{expr} #{type}&quot;
  end
end
</code></pre>

<p>Instead of returning bools to indicate if it typed checked or not, we&#39;re going to
raise an error when a type mismatch occurs, and we&#39;re going to successfully return
when valid.</p>

<h3>Back to synthesizing annotations</h3>

<p>We now have enough structure in place to synthesize annotations.</p>

<pre><code class="diff">module Expression
  LiteralInt = Data.define(:value)
  LiteralString = Data.define(:value)
  Variable = Data.define(:name)
+ Annotation = Data.define(:expression, :type)
end

def synthesize(expr, context)
  case expr
  in Expression::LiteralInt
    [Type::Int.new, context]

  in Expression::LiteralString
    [Type::String.new, context]

  in Expression::Variable(varname)
    vartype = context.lookup(varname)
    raise &quot;unknown variable&quot; if !vartype
    [vartype, context]

+ in Expression::Annotation(e, type)
+   raise &quot;invalid type&quot; if !type_well_formed?(type, context)
+   delta = check(e, type, context)
+   [type, delta]

  else
    raise &quot;unknown expression&quot;
  end
end
</code></pre>

<h3>Checkpoint 01</h3>

<p>So far our implementation allows the following expressions to be typed:</p>

<pre><code class="ruby">synthesize(
  Expression::LiteralInt.new(42),
  Context.new
) # =&gt; #&lt;data Type::Int&gt;

synthesize(
  Expression::Annotation.new(
    Expression::LiteralString.new(&quot;hello&quot;),
    Type::String.new
  ),
  Context.new
) # =&gt; #&lt;data Type::String&gt;

synthesize(
  Expression::Annotation.new(
    Expression::LiteralString.new(&quot;hello&quot;),
    Type::Int.new
  ),
  Context.new
) # =&gt; type mismatch (RuntimeError)
</code></pre>

<h3>Lambdas</h3>

<p>The typing rule for synthesizing lambdas (anonymous functions) is the following:</p>

<p><img src="/images/11_07.png" alt="type_rule_synthesize_function"></p>

<p>This rule introduces a new concept we haven&#39;t talked about yet: existential
types. The symbol ^ is used exclusively to denotate existentials. The conclusion
of this typing rule is read as: &quot;Under context gamma, lambda from <code>x</code> to <code>e</code>
synthesizes the type lambda from <code>existential alpha</code> to <code>existential beta</code> and produces a
new context delta&quot;.</p>

<p>Existential types can be thought of as
unknown types. They&#39;re unknown up to this point of the type checking process, but we
can gather more information to figure out what they are. Important: they&#39;re not like
<code>any</code> or <code>void</code>, but placeholder for a type that is yet to be determined.</p>

<p>Alpha and beta are fresh existentials. The word fresh is commonly used in
type theory and type checking to refer to newly created variables that are guaranteed
to be distinct from other variables currently in scope.
To implement this rule, we&#39;ll need a function that generates unique names.
For simplicity, we&#39;ll use a global counter, but feel free to wrap the type checking
in a class if you&#39;re using an OOP language or a monad that controls state and exceptions
if you&#39;re using FP language.</p>

<pre><code class="ruby">$fresh_name_counter = 0
def fresh_name
  $fresh_name_counter += 1
  &quot;x#{$fresh_name_counter}&quot;
end

fresh_name # =&gt; &quot;x1&quot;
fresh_name # =&gt; &quot;x2&quot;
fresh_name # =&gt; &quot;x3&quot;
</code></pre>

<p>We can break the the premise of the lambda typing rule into three parts in order to
understand it better.</p>

<p><img src="/images/11_08.png" alt="type_rule_synthesize_function_breakdown"></p>

<p>The middle part, highlighted in pink, is a recursive call to <code>check</code>. It checks
that <code>e</code>, the body of the function, checks against existential beta.</p>

<p>The first part, highlighted in red, modifies the context gamma by pushing 3
new elements to it: existential alpha, existential beta, and an annotation
(typed variable) that <code>x has type existential alpha</code>. This modified context
is the context we&#39;ll pass to <code>check</code> when checking the body of the function.</p>

<p>The last part, highlighted in green, can be seen as a pattern match. We match on
the output of <code>check</code> on <code>x has type existential alpha</code> binding the elements to
left to delta and the elements to the right to theta. In other words, take the
output of <code>check</code> and split it at the element <code>x : existential alpha</code>. Elements to
the left of this split are bound to delta and elements to the right are bound to theta.</p>

<h3>Context manipulation</h3>

<p>In order to synthesize lambdas we need to manipulate the context with
two operations: push, to add new elements to the context, and split to split a context
into two at a given <code>element</code>.</p>

<pre><code class="diff">class Context
  module Element
    TypedVariable = Data.define(:name, :type)
  end

+ def self.empty = new([])

- def initialize
+ def initialize(elements = [])
-   @elements = []
+   @elements = elements
  end

  def lookup(name)
    typed_var =
      @elements.find do |element|
        case element
        in Element::TypedVariable(varname, _) then varname == name
        else false
        end
      end

    typed_var&amp;.then { it.type }
  end

+ def push(elements)
+   Context.new(@elements + Array(elements))
+ end

+ def split(element)
+   left, right = @elements.partition { it == element }
+   [Context.new(left), Context.new(right)]
+ end
end
</code></pre>

<h3>Synthesizing lambdas</h3>

<p>We need a few extra expressions, types and context elements to synthesize lambdas.</p>

<pre><code class="diff">module Expression
  LiteralInt = Data.define(:value)
  LiteralString = Data.define(:value)
  Variable = Data.define(:name)
  Annotation = Data.define(:expression, :type)
+ Lambda = Data.define(:arg_name, :body_expr)
end

module Type
  Int = Data.define
  String = Data.define
+ Variable = Data.define(:name)
+ Existential = Data.define(:name)
+ Lambda = Data.define(:arg_type, :body_type)
end

class Context
  module Element
+   Variable = Data.define(:name)
    TypedVariable = Data.define(:name, :type)
+   UnsolvedExistential = Data.define(:name)
+   SolvedExistential = Data.define(:name, :type)
  end
end
</code></pre>

<p>We now have enough to translate the type premises into code with the following
implementation.</p>

<pre><code class="ruby">def synthesize(expr, context)
  case expr
  # ... other expressions

  in Expression::Lambda(arg_name, body_expr)
    alpha_name = fresh_name
    beta_name = fresh_name

    alpha_type = Type::Existential.new(alpha_name)
    beta_type = Type::Existential.new(beta_name)
    lambda_type = Type::Lambda.new(alpha_type, beta_type)

    arg_has_type_alpha = Context::Element::TypedVariable.new(arg_name, alpha_type)

    gamma = context.push([
      Context::Element::UnsolvedExistential.new(alpha_name),
      Context::Element::UnsolvedExistential.new(beta_name),
      arg_has_type_alpha
    ])

    output_context = check(body_expr, beta_type, gamma)
    delta, _theta = output_context.split(arg_has_type_alpha)
    [lambda_type, delta]
  end
end
</code></pre>

<p>If we try to synthesize a lambda right now, we&#39;ll get a type mismatch error because
the <code>check</code> function does not handle existentials yet.</p>

<p>The good news is that, even though it does not work yet, the implementation of
synthesize is complete. The bad news is that, due to the recursive nature of the
algorithm, we have a deep rabbit hole to get into in order to solve existentials.</p>

<h3>Solving existentials</h3>

<p>Just to be clear where we&#39;re at, when we try to synthesizing a lambda that ignores
the argument and returns a constant, we get following error:</p>

<pre><code class="ruby">puts synthesize(
  Expression::Lambda.new(&quot;x&quot;, Expression::LiteralInt.new(1)),
  Context.empty
) # =&gt;  # type mismatch: #&lt;data Expression::LiteralInt value=1&gt; #&lt;data Type::Existential name=&quot;x2&quot;&gt;
</code></pre>

<p>This happens when synthesize calls <code>check</code> with the lambda body expression and the beta existential.
To fix this problem we need to learn how to check expressions against existentials. The following
typing rule helps with that:</p>

<p><img src="/images/11_09.png" alt="type_rule_check"></p>

<p>You may read this typing rule as: &quot;Under context gamma, expression <code>e</code> type checks
against <code>B</code> and produces context delta if, and only if, under context gamma, expression
<code>e</code> synthesizes type <code>A</code> with context output theta and theta applied to <code>A</code> is a subtype of
theta applied to <code>B</code> with context output delta.&quot;. Sub stands for substitution.</p>

<p>The <code>B</code> type in this rule can be an existential, which we&#39;re interested.</p>

<p>But before we can implement this rule, there are two problems we need to solve:</p>

<ul>
<li>What does it mean to apply a context to a type?</li>
<li>What does it mean for a type to be a subtype of another type?</li>
</ul>

<h3>First problem: applying a context to a type</h3>

<p>As explained in the paper, &quot;an algorithmic context can be viewed as a substitution for
its solved existential variables&quot;. Here are the rules:</p>

<p><img src="/images/11_10.png" alt="type_rule_check"></p>

<p>From top to bottom, we can read each rule as:</p>

<ul>
<li>Type variable resolve to itself.</li>
<li>Unit/literal resolve to itself.</li>
<li>Existential <code>â</code> solved to type <code>t</code> resolve to context applied to <code>t</code>. Notice the recursion.</li>
<li>Existential <code>â</code>, unsolved, resolve to itself.</li>
<li>Lambda <code>A -&gt; B</code> resolve to <code>context applied to A -&gt; context applied to B</code>.</li>
<li>Quantification <code>∀a. A</code> resolve to <code>∀a. context applied to A</code>.</li>
</ul>

<p>We can implement <code>Contex#apply</code> for the types we already have as following:</p>

<pre><code class="Ruby">class Context
  # ... other methods

  def apply(type)
    case type
    in Type::Int
      type

    in Type::String
      type

    in Type::Variable
      type

    in Type::Existential(name)
      solved_type = find_solved_existential(name)
      solved_type ? apply(solved_type) : type

    in Type::Lambda(arg_type, body_type)
      type.with(arg_type: apply(arg_type), body_type: apply(body_type))

    else
      raise &quot;unknown type: #{type}&quot;
    end
  end

  def find_solved_existential(name)
    solved_existential =
      @elements.find do |element|
        case element
        in Element::SolvedExistential(existential_name, existential_type)
          existential_name == name
        else
          false
        end
      end

    solved_existential&amp;.then { it.type }
  end
end
</code></pre>

<h3>Second problem: subtyping</h3>

<p>If you have a background in OOP languages, it might be natural to associate
subtyping with inheritance. This is not the case here. Subtyping is a compatibility
relation between two types. When we say <code>A is a subtype of B</code> it means that <code>A</code>
can be safely used when <code>B</code> is expected. Think of general substitution instead of
inheritance.</p>

<p>Common subtyping relations include function types (covariance and contravariance),
record types (a record with name and email is a subtype of a record with name only),
union types (<code>int</code> is a subtype of <code>int or string</code>) and refinements (<code>non negative ints</code> is a subtype of <code>int</code>).
You can probably think of more examples. When designing a type system for a programming
language it is necessary to come up with subtyping rules.</p>

<p>The smallest step we can take into subtyping to unblock our lambda synthesis rule (remember
we&#39;re still digging the rabbit hole to get back to our lambda synthesis rule), is to implement
the following rules:</p>

<p><img src="/images/11_11.png" alt="type_rule_check"></p>

<p>These three rules say the same thing: a type is a subtype of itself. Type variables
are a subtype of themselves, literals are a subtype of themselves, and existentials
are a subtype of themselves. We can implement this function as follows:</p>

<pre><code class="ruby">def subtype(type_a, type_b, context)
  case [type_a, type_b]
  in [Type::Int, Type::Int]
    context

  in [Type::String, Type::String]
    context

  in [Type::Variable(name_a), Type::Variable(name_b)]
    raise &quot;subtype mismatch: #{name_a} #{name_b}&quot; if name_a != name_b
    context

  in [Type::Existential(name_a), Type::Existential(name_b)]
    raise &quot;subtype mismatch: #{name_a} #{name_b}&quot; if name_a != name_b
    context

  else
    raise &quot;subtype mismatch: #{type_a} #{type_b}&quot;
  end
end
</code></pre>

<h3>Back to checking</h3>

<p>As a reminder, here is the rule for checking an expression against a type:</p>

<p><img src="/images/11_09.png" alt="type_rule_check"></p>

<p>With <code>Context#apply</code> and <code>subtype</code> we now have enough tools to improve our implementation
of <code>check</code>:</p>

<pre><code class="diff">def check(expr, type, context)
  case [expr, type]

  in [Expression::LiteralInt, Type::Int]
    context

  in [Expression::LiteralString, Type::String]
    context

  else
-   raise &quot;type mismatch: #{expr} #{type}&quot;
+   synthesized_type, theta = synthesize(expr, context)
+   subtype(theta.apply(synthesized_type), theta.apply(type), theta)
  end
end
</code></pre>

<p>This change moves our error from &quot;type mismatch&quot; to &quot;subtype mismatch&quot;. Progress.</p>

<h3>Subtyping against existentials</h3>

<p>The rule for subtyping against existentials is the following:</p>

<p><img src="/images/11_12.png" alt="type_rule_check"></p>

<p>We can read this rule as &quot;under context gamma containing the existential alpha, type <code>A</code> is a subtype of
alpha and produces context delta if, and only if, alpha does not occur in <code>A</code> and
<code>A</code> can be instantiated to alpha with context output delta.&quot;</p>

<p>Instantiation is a new concept we haven&#39;t talked about yet, but before we get there,
let&#39;s talk about the occurs check.</p>

<h3>Occurs check</h3>

<p>The paper does not provide an implementation for occurs, so we will come up with
one ourselves. The problem we&#39;re trying to prevent is circular or recursive types
that would expand to infinity when instantiated.</p>

<pre><code class="ruby">def occurs?(name, type)
  case type
  in Type::Int
    false

  in Type::String
    false

  in Type::Variable(var_name)
    var_name == name

  in Type::Existential(existential_name)
    existential_name == name

  in Type::Lambda(arg_type, return_type)
    occurs?(name, arg_type) || occurs?(name, return_type)

  else
    raise &quot;unknown type: #{type}&quot;
  end
end
</code></pre>

<h3>Back to instantiation</h3>

<p>Type instantiation comes in two flavors: left instantiation, where we instantiate an existential
against a type, and right instantiation, where we instantiate a type against an existential.</p>

<p>Lambda expression synthesis requires right instantiation because we check the type of the body
expression against the beta-existential generated by the synthesis rule.</p>

<p>The smallest step we can take into implementing right instantiation is the following rule:</p>

<p><img src="/images/11_13.png" alt="type_rule_check"></p>

<p>We can read this as: &quot;under context gamma containing alpha, alpha is instantiated to type <code>t</code>
if <code>t</code> is well formed and produces context gamma replacing unsolved alpha with alpha solved
to <code>t</code>.&quot; The notation used for t (lower case tau) suggests that is must be a monotype, so we
also need to add this check.</p>

<p>The implementation of <code>monotype?</code> is redundant because we haven&#39;t seen quantifications yet,
but let&#39;s define it anyway so we have a place to extend it later.</p>

<pre><code class="ruby">def monotype?(type)
  case type
  in Type::Lambda(arg_type, body_type)
    monotype?(arg_type) &amp;&amp; monotype?(body_type)

  else
    true
  end
end

def instantiate_right(type, existential_name, context)
  if monotype?(type) &amp;&amp; type_well_formed?(type, context)
    return context.replace(
      Context::Element::UnsolvedExistential.new(existential_name),
      Context::Element::SolvedExistential.new(existential_name, type)
    )
  end

  raise &quot;invalid right instantiation: #{type} #{existential_name}&quot;
end
</code></pre>

<p>As well as the <code>Context#replace</code>:</p>

<pre><code class="ruby">class Context
  # ... other methods

  def replace(element_old, element_new)
    elements = @elements.flat_map { |element| element == element_old ? Array(element_new) : element }

    Context.new(elements)
  end
end
</code></pre>

<p>We also need to update our <code>type_well_formed?</code> function to support type variables,
existentials and lambdas:</p>

<pre><code class="ruby">class Context
  # ... other methods

  def has?(element)
    @elements.include?(element)
  end
end

def type_well_formed?(type, context)
  case type
  # we only had these two cases before for literal values
  in Type::Int then true
  in Type::String then true

  in Type::Variable(name)
    context.has?(Context::Element::Variable.new(name))

  in Type::Existential(name)
    context.has?(Context::Element::UnsolvedExistential.new(name)) ||
      context.find_solved_existential(name).present?

  in Type::Lambda(arg_type, body_type)
    type_well_formed?(arg_type, context) &amp;&amp; type_well_formed?(body_type, context)

  else
    raise &quot;unknown type: #{type}&quot;
  end
end
</code></pre>

<p>With these functions in place, we have enough in place to delegate to subtying
existentials to right instantiation:</p>

<pre><code class="diff">def subtype(type_a, type_b, context)
  case [type_a, type_b]

  in [Type::Int, Type::Int]
    context

  in [Type::String, Type::String]
    context

  in [Type::Variable(name_a), Type::Variable(name_b)]
    raise &quot;subtype mismatch: #{name_a} #{name_b}&quot; if name_a != name_b
    context

  in [Type::Existential(name_a), Type::Existential(name_b)]
-   raise &quot;subtype mismatch: #{name_a} #{name_b}&quot; if name_a != name_b
+   return context if name_a == name_b
+   instantiate_right(type_a, name_b, context)

+ in [_, Type::Existential(existential_name)]
+   raise &quot;circular instantiation: #{type_a} #{type_b}&quot; if occurs?(existential_name, type_a)
+   instantiate_right(type_a, existential_name, context)

  else
    raise &quot;subtype mismatch: #{type_a} #{type_b}&quot;
  end
end
</code></pre>

<p>Finally no more errors now when synthesizing this one lambda:</p>

<pre><code class="ruby">puts synthesize(
  Expression::Lambda.new(&quot;x&quot;, Expression::LiteralInt.new(1)),
  Context.empty
) # =&gt; #&lt;data Type::Lambda arg_type=#&lt;data Type::Existential name=&quot;x1&quot;&gt;, bodytype=#&lt;data Type::Existential name=&quot;x2&quot;&gt;&gt;
</code></pre>

<p>Although the inferred type looks weird with existentials, it&#39;s correct. We&#39;re
finally out of the rabbit hole, and, good news, we have covered the whole algorithm
end to end. There are still gaps in our implementation, but there are no more
side tracks or new concepts or new abstractions to learn. Apart from one extra function
we have not yet implemented (left instantiation), we&#39;ll mostly be modifying our
existing functions instead of adding new ones.</p>

<p>Out of the 28 typing rules in the algorithm, we have implemented 11 of them. For visual
people, here&#39;s the typing rules we&#39;ve implemented, highlighted in red:</p>

<p><img src="/images/11_15.png" alt="type_rule_check"></p>

<p>If you want to take a break, it&#39;s good time now.</p>

<h3>Existentials subtyping existentials</h3>

<p>Let&#39;s continue our journey by synthesizing the famous identity function <code>λa.a</code>.</p>

<p>If we try to synthesize the identity function we get the following error: &quot;subtype mismatch: x1 x2 (RuntimeError)&quot;.
This is because our right instantiation function is very limited. The typing rule
we need to support now is the following:</p>

<p><img src="/images/11_16.png" alt="type_rule_check"></p>

<p>This rule states that &quot;under context gamma existential beta is a subtype of existential alpha if,
and only if, existential alpha exists in gamma and it is defined in a position before existential beta,
with output gamma having existential beta solved to existential alpha&quot;.</p>

<p>For practical purposes, we can implement right instantiation to whatever existential
appears before the other.</p>

<p>We need to add a helper method on context <code>Context#index</code> that returns the position
of an element. Then we can modify <code>instantiate_right</code> to consider subtyping
existentials</p>

<pre><code class="diff">class Context
  # ... other methods

+ def index(element)
+   @elements.index(element)
+ end
end

def instantiate_right(type, existential_name, context)
  if type_well_formed?(type, context)
    return context.replace(
      Context::Element::UnsolvedExistential.new(existential_name),
      Context::Element::SolvedExistential.new(existential_name, type)
    )
  end

- raise &quot;invalid right instantiation: #{type} #{existential_name}&quot;
+ case type
+ in Type::Existential(beta_name)
+   alpha_name = existential_name
+   alpha = Context::Element::UnsolvedExistential(alpha_name)
+   beta = Context::Element::UnsolvedExistential(beta_name)
+   if context.index(alpha) &lt; context.index(beta)
+     solved = Context::Element::SolvedExistential.new(beta_name, Type::Existential.new(alpha_name))
+     context.replace(beta, solved)
+   else
+     solved = Context::Element::SolvedExistential.new(alpha_name, Type::Existential.new(beta_name))
+     context.replace(alpha, solved)
+   end
+
+ else
+   raise &quot;invalid right instantiation: #{type} #{existential_name}&quot;
+ end
end
</code></pre>

<p>We can now synthesize the id function correctly.</p>

<pre><code class="ruby">puts synthesize(
  Expression::Lambda.new(&quot;x&quot;, Expression::Variable.new(&quot;x&quot;)),
  Context.empty
) # =&gt; #&lt;data Type::Lambda arg_type=#&lt;data Type::Existential name=&quot;x1&quot;&gt;, bodytype=#&lt;data Type::Existential name=&quot;x2&quot;&gt;&gt;
</code></pre>

<p>We cannot annotate it yet because we&#39;re still missing quantification types.</p>

<h3>Quantification types</h3>

<p>The signature of the id function is <code>forall. a -&gt; a</code>. For all is known as
universal quantification in the paper. To support quantifications, we need
to add the type definition and update our implementation of <code>type_well_formed?</code>,
<code>occurs?</code> and <code>Context#apply</code>.</p>

<pre><code class="ruby">module Type
  # ...
  Quantification = Data.define(:name, :subtype)
end

def type_well_formed?(type, context)
  case type
  # ...
  in Type::Quantification(name, subtype)
    type_well_formed?(subtype, context.push(Context::Element::Variable.new(name)))
  end
end

def monotype?(type)
  case type
  # ...
  in Type::Quantification
    false
  end
end

def occurs?(name, type)
  case type
  # ...
  in Type::Quantification(alpha, subtype)
    name == alpha || occurs?(name, subtype)
  end
end

class Context
  def apply(type)
    case type
    # ...
    in Type::Quantification(name, subtype)
      type.with(subtype: apply(subtype))
    end
  end
end
</code></pre>

<p>This gets us closer to annotating the id function, but now we&#39;re stuck on subtyping
a lambda type with a quantification.</p>

<pre><code class="ruby">puts synthesize(
  Expression::Annotation.new(
    Expression::Lambda.new(&quot;x&quot;, Expression::Variable.new(&quot;x&quot;)),
    Type::Quantification.new(&quot;a&quot;, Type::Lambda.new(Type::Variable.new(&quot;a&quot;), Type::Variable.new(&quot;a&quot;)))
  ),
  Context.empty
) # subtype mismatch: #&lt;data Type::Lambda arg_type=#&lt;data Type::Existential name=&quot;x1&quot;&gt;, body_type=#&lt;data Type::Existential name=&quot;x2&quot;&gt;&gt; #&lt;data Type::Quantification name=&quot;a&quot;, subtype=#&lt;data Type::Lambda arg_type=#&lt;data Type::Variable name=&quot;a&quot;&gt;, body_type=#&lt;data Type::Variable name=&quot;a&quot;&gt;&gt;&gt; (RuntimeError)
</code></pre>

<p>The typing rule we need to make progress is the following:</p>

<p><img src="/images/11_17.png" alt="type_rule_check"></p>

<p>This rule acts like an expansion step to other typing rules. We expand the
quantification type by adding the quantification varible to the context, and then
call <code>subtype</code> again with this modified context. When returning, we drop the
variable. This is what the <code>Delta, alpha, Theta</code> means.</p>

<pre><code class="ruby">def subtype(type_a, type_b, context)
  case [type_a, type_b]
  # ...
  in [_, Type::Quantification(name, subtype)]
    alpha_var = Context::Element::Variable.new(name)
    gamma = context.push(alpha_var)
    result = subtype(type_a, subtype, gamma)
    delta, _theta = result.split(alpha_var)
    delta
  end
end
</code></pre>

<p>With this rule in place we&#39;ve changed the error from a subtype mistmatch between
a lambda and a quantification to a subtype mismatch between two lambdas. The
first lambda type is the result from calling synthesize. The second lambda type
is the result from expanding the quantification present in the annotation.</p>

<pre><code>subtype mismatch:
#&lt;data Type::Lambda arg_type=#&lt;data Type::Existential name=&quot;x1&quot;&gt;, body_type=#&lt;data Type::Existential name=&quot;x2&quot;&gt;&gt;
#&lt;data Type::Lambda arg_type=#&lt;data Type::Variable name=&quot;a&quot;&gt;, body_type=#&lt;data Type::Variable name=&quot;a&quot;&gt;&gt;
</code></pre>

<h3>Subtyping lambdas</h3>

<p>The typing rule we need to make progress now is the following:</p>

<p><img src="/images/11_18.png" alt="type_rule_check"></p>

<p>The conclusion is mostly straight forward, but the premise describes an interesting
relation for covariance and contravariance. Notice that the subtyping order is
different for the argument type and the body type (aka return type). <code>B1</code> must be
a subtype of <code>A1</code> (argument), while <code>A2</code> must be a subtype of <code>B2</code> (return).</p>

<p>We have all the pieces in place to implement this rule, so let&#39;s go ahead and modify
the <code>subtype</code> function to handle this case.</p>

<pre><code class="ruby">def subtype(type_a, type_b, context)
  case [type_a, type_b]
  # ...
  in [Type::Lambda(a1, a2), Type::Lambda(b1, b2)]
    theta = subtype(b1, a1, context)
    delta = subtype(theta.apply(a2), theta.apply(b2), theta)
    delta
  end
end
</code></pre>

<p>The error changed again. We&#39;re now one level deep into the previous error. Progress.</p>

<pre><code>subtype mismatch: #&lt;data Type::Existential name=&quot;x2&quot;&gt; #&lt;data Type::Variable name=&quot;a&quot;&gt;
</code></pre>

<p>The existential <code>x2</code> is the synthesized type for the body of our lambda. The type variable
<code>a</code> is the annotation we provided. You might have notice that the existential appears
on the left side of the relation instead of the right side. This means we need to
look into left instantiation to continue making progress.</p>

<h3>Left instantiation</h3>

<p>The first typing rule that is going to enable instanting existentials on the left is
the following:</p>

<p><img src="/images/11_19.png" alt="type_rule_check"></p>

<p>This is very, very similar to the first rule we saw for right instantiation. We
can implement it with the following code:</p>

<pre><code class="ruby">def instantiate_left(type, existential_name, context)
  if monotype?(type) &amp;&amp; type_well_formed?(type, context)
    return context.replace(
      Context::Element::UnsolvedExistential.new(existential_name),
      Context::Element::SolvedExistential.new(existential_name, type)
    )
  end

  raise &quot;invalid left instantiation: #{type} #{existential_name}&quot;
end
</code></pre>

<p>Then, we can call <code>instantiate_left</code> from <code>subtype</code> as described by the following
type rule, which looks very similar to the rule that delegates subtyping to right
instantiation:</p>

<p><img src="/images/11_20.png" alt="type_rule_check"></p>

<pre><code class="ruby">def subtype(type_a, type_b, context)
  case [type_a, type_b]
  # ...
  in [Type::Existential(existential_name), _]
    raise &quot;circular instantiation: #{type_a} #{type_b}&quot; if occurs?(existential_name, type_b)
    instantiate_left(type_b, existential_name, context)
  end
end
</code></pre>

<p>We can finally annotate our id function successfully!</p>

<pre><code class="ruby">puts synthesize(
  Expression::Annotation.new(
    Expression::Lambda.new(&quot;x&quot;, Expression::Variable.new(&quot;x&quot;)),
    Type::Quantification.new(&quot;a&quot;, Type::Lambda.new(Type::Variable.new(&quot;a&quot;), Type::Variable.new(&quot;a&quot;)))
  ),
  Context.empty
) # =&gt; #&lt;data Type::Quantification name=&quot;a&quot;, subtype=#&lt;data Type::Lambda arg_type=#&lt;data Type::Variable name=&quot;a&quot;&gt;, body_type=#&lt;data Type::Variable name=&quot;a&quot;&gt;&gt;&gt;
</code></pre>

<p>Now that we can define the id function, let&#39;s call it with some values to make
sure it behaves as expected. So our next is now is calling functions, which is also
known as application.</p>

<h3>Applications</h3>

<p>The rule that describes application synthesis is the following:</p>

<p><img src="/images/11_21.png" alt="app_rule"></p>

<p>The conclusion states that <code>e2</code> applied to <code>e1</code> synthesizes type <code>C</code>. For application
to work, <code>e1</code> must resolve to a lambda and <code>e2</code> must be a value of the same type as the
argument type of the lambda. Just to be clear, <code>e1</code> does not need to be a literal lambda,
it could be a variable that stands for a lambda that we resolve via lookup.</p>

<p>This is our first time seeing the green arrow notation. This notation is similar to
regular synthesize but specialized for the result of applying a function to a value.</p>

<p>To apply <code>e1</code> to <code>e2</code> we first synthesize <code>e1</code>. This is described in first premise.
The result of this synthesis needs to be a lambda, an existential or a quantification.
Everything else is invalid. It might be useful to peek ahead some extra typing rules
to see the full picture of application synthesizes.</p>

<p><img src="/images/11_22.png" alt="app_rule"></p>

<p>I&#39;ve highlighted <code>e1 synthesizes A</code> in red. The pink arrow points to the typing
rule when <code>A</code> is an existential. The yellow arrow points to the typing rule when
<code>A</code> is a lambda. The blue arrow points to the typing rule when <code>A</code> is a quantification,
which, as you might have noticed, expands the quantification and calls synthesize again.</p>

<p>The typing rule for quantification describes substitution, which we haven&#39;t seen yet.
The notation used is <code>[â/a]A</code>. The notation for substitution is famously inconsistent
across different papers, but in this case, we can read <code>[â/a]A</code> as &quot;substitute <code>a</code> with <code>â</code> in <code>A</code>&quot;.</p>

<h3>Substitution</h3>

<p>The paper does not provide an implementation for substitution, but we can implement it ourselves.</p>

<pre><code class="ruby">def substitute(substitution_type, alpha, original_type)
  case original_type
  in Type::Variable(name)
    name == alpha ? substitution_type : original_type

  in Type::Existential(name)
    name == alpha ? substitution_type : original_type

  in Type::Lambda(arg_type, body_type)
    original_type.with(
      arg_type: substitute(substitution_type, alpha, arg_type),
      body_type: substitute(substitution_type, alpha, body_type)
    )

  in Type::Quantification(name, subtype)
    if name == alpha
      original_type.with(subtype: substitution)
    else
      original_type.with(subtype: substitute(substitution_type, alpha, subtype))
    end

  else
    original_type
  end
end
</code></pre>

<h3>Back to applications</h3>

<p>I believe we can implement all four application synthesis rules at once. Let&#39;s
start with defining an expression for application.</p>

<pre><code class="diff">module Expression
  LiteralInt = Data.define(:value)
  LiteralString = Data.define(:value)
  Variable = Data.define(:name)
  Annotation = Data.define(:expression, :type)
  Lambda = Data.define(:arg_name, :body_expr)
+ Application = Data.define(:lambda, :arg)
end
</code></pre>

<p>The first step is to handle <code>Expression::Application</code> on the <code>synthesize</code> function
and then delegate to <code>synthesize_application</code> to continue into this branch.</p>

<pre><code class="ruby">def synthesize(expr, context)
  case expr
  # ...
  in Expression::Application(e1, e2)
    a, theta = synthesize(e1, context)
    c, delta = synthesize_application(theta.apply(a), e2, theta)
    [c, delta]
  end
end
</code></pre>

<p>Then we can implement <code>synthesize_application</code> with the three typing rules we have
seen earlier.</p>

<pre><code class="ruby">def synthesize_application(lambda_type, arg_expr, context)
  case lambda_type

  # Figure 10. ∀App
  #
  # Γ, â ⊢ [â/a]A·e =&gt;=&gt; C ⊣ Δ
  # --------------------------
  # Γ ⊢ ∀a.A·e =&gt;=&gt; C ⊣ Δ
  in Type::Quantification(alpha, a)
    â_name = fresh_name
    â_unsolved = Context::Element::UnsolvedExistential.new(â_name)
    â_type = Type::Existential.new(â_name)
    gamma = context.push(â_unsolved)
    substituted_a = substitute(â_type, alpha, a)
    synthesize_application(substituted_a, arg_expr, gamma)

  # Figure 10. âApp
  #
  # Γ[â2, â1, â = â1 -&gt; â2] ⊢ e &lt;= â1 ⊣ Δ
  # -------------------------------------
  # Γ[â] ⊢ â·e =&gt;=&gt; â2 ⊣ Δ
  in Type::Existential(â)
    â1_name = fresh_name
    â2_name = fresh_name
    â1 = Context::Element::UnsolvedExistential.new(â1_name)
    â2 = Context::Element::UnsolvedExistential.new(â2_name)
    â_solved = Context::Element::SolvedExistential.new(â, Type::Lambda.new(Type::Existential.new(â1), Type::Existential.new(â2)))
    gamma = context.replace(Context::Element::UnsolvedExistential.new(â), [â2, â1, â_solved])
    delta = check(arg_expr, Type::Existential.new(â1_name), gamma)
    [Type::Existential.new(â2_name), delta]

  # Figure 10. -&gt;App
  #
  # Γ ⊢ e &lt;= A ⊣ Δ
  # -----------------------
  # Γ ⊢ A -&gt; C·e =&gt;=&gt; C ⊣ Δ
  in Type::Lambda(arg_type, body_type)
    delta = check(arg_expr, arg_type, context)
    [body_type, delta]

  else
    raise &quot;unexpected application: #{lambda_type}&quot;
  end
end
</code></pre>

<p>With this in place, we can hopefully synthesize an application to our id function
and get back the expected type.</p>

<pre><code class="ruby">id = Expression::Annotation.new(
  Expression::Lambda.new(&quot;x&quot;, Expression::Variable.new(&quot;x&quot;)),
  Type::Quantification.new(&quot;a&quot;, Type::Lambda.new(Type::Variable.new(&quot;a&quot;), Type::Variable.new(&quot;a&quot;)))
)

puts synthesize(
  Expression::Application.new(id, Expression::LiteralInt.new(42)),
  Context.empty
) # =&gt; #&lt;data Type::Existential name=&quot;x5&quot;&gt;

puts synthesize(
  Expression::Application.new(id, Expression::LiteralString.new(&quot;foo&quot;)),
  Context.empty
) # =&gt; #&lt;data Type::Existential name=&quot;x8&quot;&gt;
</code></pre>

<p>Well, that&#39;s a little disappointing. But wait! We&#39;re still missing one last step to resolve the existential into a meaningful type. We just need to apply
the output context to the output type. Let&#39;s create a helper function to
be the entry point of our algorithm:</p>

<pre><code class="rb">def infer(expr)
  type, context = synthesize(expr, Context.empty)
  context.apply(type)
end
</code></pre>

<p>With this, we finally have the output we were expecting!</p>

<pre><code class="ruby">puts infer(
  Expression::Application.new(id, Expression::LiteralInt.new(42))
) # =&gt; #&lt;data Type::Int&gt;

puts infer(
  Expression::Application.new(id, Expression::LiteralString.new(&quot;foo&quot;))
) # =&gt; #&lt;data Type::String&gt;
</code></pre>

<p>We have implemented 19 out of the 28 typing rules. We&#39;re over 70% of the way there.
In fact, we are so close to being done that there is only one more concept we
haven&#39;t seen.</p>

<h3>Context markers</h3>

<p>Context markers are placeholders used to facilitate splitting after calling functions
that modify the context. We can see the notation in this typing rule:</p>

<p><img src="/images/11_24.png" alt="app_rule"></p>

<p>Notice there is a caret symbol pointing right. This is a marker. The only purpose
of this marker is being used to split the context after recursively invoking <code>subtype</code>.
Notice that delta is everything before the marker, and theta is everything after the marker.</p>

<p>Let&#39;s add the marker definition as a context element.</p>

<pre><code class="diff">class Context
  module Element
    Variable = Data.define(:name)
    TypedVariable = Data.define(:name, :type)
    UnsolvedExistential = Data.define(:name)
    SolvedExistential = Data.define(:name, :type)
+   Marker = Data.define(:name)
  end
end
</code></pre>

<p>This typing rule is a bit tricky. In order to invoke its path, we need to subtype
a quantification with another type. The most common way for a quantification to
appear on the left of a subtype is when a function accepts another function as
an argument. For example:</p>

<pre><code>call42 :: (Int -&gt; Int) -&gt; Int
call42 f = f 42

call42 id
</code></pre>

<p>In this example, <code>call42</code> expects a function <code>Int -&gt; Int</code>, and we provide <code>forall a. a -&gt; a</code>.
This is valid, but our type checker currenntly fails with a subtype error telling us that
quantification is not a subtype of lambda.</p>

<p>Let&#39;s fix this by implementing the typing rule on the <code>subtype</code> function.</p>

<pre><code class="ruby">def subtype(type_a, type_b, context)
  case [type_a, type_b]
    # ...
    in [Type::Quantification(alpha, a), _]
      â_name = fresh_name
      â_marker = Context::Element::Marker.new(â_name)
      â_unsolved = Context::Element::UnsolvedExistential.new(â_name)
      â_type = Type::Existential.new(â_name)
      substituted_a = substitute(â_type, alpha, a)
      gamma = context.push(â_marker).push(â_unsolved)
      result = subtype(substituted_a, type_b, gamma)
      delta, _theta = result.split(â_marker)
      delta
  end
end
</code></pre>

<p>With this we can synthesize our previous example with <code>call42</code>.</p>

<pre><code class="ruby">id = Expression::Annotation.new(
  Expression::Lambda.new(&quot;x&quot;, Expression::Variable.new(&quot;x&quot;)),
  Type::Quantification.new(&quot;a&quot;, Type::Lambda.new(Type::Variable.new(&quot;a&quot;), Type::Variable.new(&quot;a&quot;)))
)

call42 = Expression::Annotation.new(
  Expression::Lambda.new(
    &quot;f&quot;,
    Expression::Application.new(Expression::Variable.new(&quot;f&quot;), Expression::LiteralInt.new(42))
  ),
  Type::Lambda.new(
    Type::Lambda.new(Type::Int.new, Type::Int.new),
    Type::Int.new
  )
)

puts infer(Expression::Application.new(call42, id)) # =&gt; #&lt;data Type::Int&gt;
</code></pre>

<h3>The final 8 typing rules...</h3>

<p>... will be left as an exercise for the reader 😁. If you&#39;re interested in the full
implementation, the code is available on <a href="https://gist.github.com/luizpvas/4f13ac409095c08bb8c0616af53104e4">this gist</a>.</p>

<p>Here are missing typing rules:</p>

<h4>Algorithmic typing</h4>

<p><img src="/images/11_25.png" alt="app_rule">
<img src="/images/11_26.png" alt="app_rule"></p>

<h4>Algorithmic subtyping</h4>

<p><img src="/images/11_27.png" alt="app_rule"></p>

<h4>Instantiation</h4>

<p><img src="/images/11_28.png" alt="app_rule">
<img src="/images/11_29.png" alt="app_rule">
<img src="/images/11_30.png" alt="app_rule">
<img src="/images/11_31.png" alt="app_rule">
<img src="/images/11_32.png" alt="app_rule"></p>

      </div>
    </main>

    <script>hljs.highlightAll();</script>
  </body>
</html>
